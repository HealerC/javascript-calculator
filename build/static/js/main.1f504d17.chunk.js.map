{"version":3,"sources":["display.js","calculator-constants.js","buttons.js","history.js","App.js","index.js"],"names":["Display","props","modifiedExpression","expression","replace","match","id","dangerouslySetInnerHTML","__html","result","handleEquals","stack","BODMAS","i","length","presentOperator","indexOf","j","calculate","elementsBeforeX","slice","elementsAfterY","toString","err","NaN","x","y","operator","Number","CALC_CONSTANTS","one","two","three","four","five","six","seven","eight","nine","zero","decimal","divide","multiply","subtract","add","clear","backspace","equals","Buttons","useEffect","handleKeyPress","event","keyPressed","key","toLowerCase","keys","Object","document","getElementById","click","addEventListener","removeEventListener","onClick","handleClick","className","style","opacity","History","useState","isDisplaying","toggleDisplay","toggleHistory","calcHistoryProperty","window","screen","width","height","calcHistoryStyle","visibility","property","history","map","item","index","clearHistory","App","state","displayingEquals","bind","validateExpression","charClicked","target","this","setState","newExpression","substring","isNaN","completeExpression","push","letterClicked","textContent","nextChar","charAt","digitRegex","lastCharGroup","test","storedHistory","JSON","parse","localStorage","getItem","alert","calcHistory","scrollHeight","scrollTop","clientHeight","setItem","stringify","href","title","rel","React","Component","ReactDOM","render"],"mappings":"8QA+CeA,EA7CC,SAACC,GAWf,IAEIC,EAAqBD,EAAME,WAgB/B,OAfAD,EAAqBA,EAAmBE,QAHf,aAGyC,SAACC,GACjE,OAAOA,GACL,IAAK,IACH,MAAO,8BACT,IAAK,IACH,MAAO,+BACT,IAAK,IACH,MAAO,+BACT,IAAK,IACH,MAAO,gCACT,QACE,OAAOA,MAKX,yBAAKC,GAAG,gBAGiB,KAArBL,EAAME,WAAoB,wBAAIG,GAAG,WAAP,KACxB,wBAAIA,GAAG,UAAUC,wBACd,CAACC,OAAQN,KAIG,KAAjBD,EAAMQ,OAAgB,wBAAIH,GAAG,aAAP,QACA,wBAAIA,GAAG,aAAaL,EAAMQ,U,OCpBxD,SAASC,EAAaP,GASpB,IALA,IACIQ,EAAQR,EAAWE,MADZ,yDAGLO,EAAS,CAAC,IAAK,IAAK,IAAK,KAEtBC,EAAI,EAAGA,EAAID,EAAOE,OAAQD,IAAK,CACtC,IAAIE,EAAkBH,EAAOC,GAE7B,GAAIV,EAAWa,QAAQD,IAAoB,EAEzC,IAAK,IAAIE,EAAI,EAAGA,EAAIN,EAAMG,OAAQG,GAAK,EAErC,GAAIN,EAAMM,KAAOF,EAAiB,CAIhC,IAEMN,EAASS,EAFPP,EAAMM,EAAE,GACRN,EAAMM,EAAE,GACeF,GAC3BI,EAAkBR,EAAMS,MAAM,EAAGH,EAAE,GACnCI,EAAiBV,EAAMS,MAAMH,EAAE,GAEnCN,EADY,sBAAOQ,GAAP,CAAwBV,GAAxB,YAAmCY,IAE/CJ,GAAK,GAMb,IACE,OAAON,EAAM,GAAGW,WAChB,MAAMC,GACN,OAAOC,KAGX,SAASN,EAAUO,EAAGC,EAAGC,GAGvB,OAFAF,EAAIG,OAAOH,GACXC,EAAIE,OAAOF,GACJC,GACL,IAAK,IACH,OAAOF,EAAIC,EACb,IAAK,IACH,OAAOD,EAAIC,EACb,IAAK,IACH,OAAOD,EAAIC,EACb,IAAK,IACH,OAAOD,EAAIC,EACb,QACE,OAAQ,GAICG,MA5EQ,CACrBC,IAAK,IACLC,IAAK,IACLC,MAAO,IACPC,KAAM,IACNC,KAAM,IACNC,IAAK,IACLC,MAAO,IACPC,MAAO,IACPC,KAAM,IACNC,KAAM,IACNC,QAAS,IACTC,OAAQ,IACRC,SAAU,IACVC,SAAU,IACVC,IAAK,IACLC,MAAO,IACPC,UAAW,YACXC,OAAQ,KCgEKC,EAjFC,SAAC/C,GA8Cf,OAzCAgD,qBAAU,WAER,SAASC,EAAeC,GACtB,IAAMC,EAAaD,EAAME,IAAIC,cAC7B,OAAOF,GACL,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACjE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACjE,IAAK,IAAK,IAAK,YAAa,IAAK,IAC/B,IAAMG,EAAOC,OAAOD,KAAK1B,GACrBvB,EAAK,GACT,IAAK,IAAI+C,KAAOE,EAIV1B,EAAe0B,EAAKF,MAAUD,IAEhC9C,EAAKiD,EAAKF,IAGdI,SAASC,eAAepD,GAAIqD,QAC5B,MACF,IAAK,QACHF,SAASC,eAAe,UAAUC,QAClC,MACF,IAAK,IACHF,SAASC,eAAe,SAASC,QACjC,MACF,IAAK,IACHF,SAASC,eAAe,kBAAkBC,QAC1C,MACF,QACE,QAKN,OAFAF,SAASG,iBAAiB,UAAWV,GAE9B,WACLO,SAASI,oBAAoB,UAAWX,OAK1C,yBAAK5C,GAAG,eAGN,4BAAQA,GAAG,QAAQwD,QAAS7D,EAAM8D,aAAlC,KACA,4BAAQzD,GAAG,SAAS0D,UAAU,WAAWF,QAAS7D,EAAM8D,aACtD,uBAAGC,UAAU,mBACf,4BAAQ1D,GAAG,WAAW0D,UAAU,WAAWF,QAAS7D,EAAM8D,aACxD,uBAAGC,UAAU,kBACf,4BAAQ1D,GAAG,YAAY0D,UAAU,WAAWF,QAAS7D,EAAM8D,aACzD,uBAAGC,UAAU,sBAEf,4BAAQ1D,GAAG,QAAQwD,QAAS7D,EAAM8D,aAAlC,KACA,4BAAQzD,GAAG,QAAQwD,QAAS7D,EAAM8D,aAAlC,KACA,4BAAQzD,GAAG,OAAOwD,QAAS7D,EAAM8D,aAAjC,KACA,4BAAQzD,GAAG,WAAW0D,UAAU,WAAWF,QAAS7D,EAAM8D,aACxD,uBAAGC,UAAU,kBAEf,4BAAQ1D,GAAG,OAAOwD,QAAS7D,EAAM8D,aAAjC,KACA,4BAAQzD,GAAG,OAAOwD,QAAS7D,EAAM8D,aAAjC,KACA,4BAAQzD,GAAG,MAAMwD,QAAS7D,EAAM8D,aAAhC,KACA,4BAAQzD,GAAG,MAAM0D,UAAU,WAAWF,QAAS7D,EAAM8D,aACnD,uBAAGC,UAAU,iBAEf,4BAAQ1D,GAAG,MAAMwD,QAAS7D,EAAM8D,aAAhC,KACA,4BAAQzD,GAAG,MAAMwD,QAAS7D,EAAM8D,aAAhC,KACA,4BAAQzD,GAAG,QAAQwD,QAAS7D,EAAM8D,aAAlC,KACA,4BAAQzD,GAAG,SAASwD,QAAS7D,EAAM8D,aAAa,0BAAME,MAAO,CAACC,QAAQ,MAAtB,KAAoC,uBAAGF,UAAU,mBAEjG,4BAAQ1D,GAAG,OAAOwD,QAAS7D,EAAM8D,aAAjC,KACA,4BAAQzD,GAAG,UAAUwD,QAAS7D,EAAM8D,aAApC,O,eCASI,EA7EC,SAAClE,GAAU,MAKemE,oBAAS,GALxB,mBAKjBC,EALiB,KAKHC,EALG,KAQzB,SAASC,IACP,OAAsBD,GAAfD,GAUT,IAEIG,EAAsB,GAGxBA,EADEC,OAAOC,OAAOC,OAAS,IAHR,CAACC,OAAQ,QADV,CAACD,MAAO,QAW1B,IAAIE,EAAmB,GACvB,GAAIR,GAEFQ,EAAmBL,GACFM,WAAa,cACxB,CAAC,IAAD,EAIFC,EAAWvB,OAAOD,KAAKiB,GAAqB,GAChC,mBACbO,EAAW,GADE,2BAEF,UAFdF,EAAgB,EAKlB,OACE,yBAAKvE,GAAG,gBAEJ+D,EAAe,yBAAK/D,GAAG,iBAAiBwD,QAASS,GAC/B,uBAAGP,UAAU,yBAChB,yBAAK1D,GAAG,iBAAiBwD,QAASS,GAC/B,uBAAGP,UAAU,0BAIjC,yBAAK1D,GAAG,eAAe2D,MAAOY,GAC5B,uBAAGb,UAAU,iBAAiB1D,GAAG,iBAEjC,yBAAKA,GAAG,WAEJL,EAAM+E,SAAW/E,EAAM+E,QAAQC,KAAI,SAACC,EAAMC,GAC1C,OAAO,yBAAK9B,IAAK8B,GAAO,4BAAKD,EAAK/E,YAAgB,2BAAI+E,EAAKzE,aAM7D4D,GAAgB,yBAAK/D,GAAG,WACpB,yBAAKA,GAAG,gBAAgBwD,QAAS7D,EAAMmF,cACvC,uBAAGpB,UAAU,0BC2OZqB,G,wDAlSb,WAAYpF,GAAQ,IAAD,8BACjB,cAAMA,IACDqF,MAAQ,CACXnF,WAAY,GACZM,OAAQ,GAGRuE,QAAS,GAITO,kBAAkB,GAGpB,EAAKxB,YAAc,EAAKA,YAAYyB,KAAjB,gBACnB,EAAKJ,aAAe,EAAKA,aAAaI,KAAlB,gBACpB,EAAKC,mBAAqB,EAAKA,mBAAmBD,KAAxB,gBAhBT,E,wDAkBPrC,GAAO,IAAD,OAGVuC,EAAcvC,EAAMwC,OAAOrF,GACjC,OAAOoF,GACL,IAAK,QACHE,KAAKC,SAAS,CACZ1F,WAAY,GACZM,OAAQ,KAEV,MACF,IAAK,YACHmF,KAAKC,UAAS,SAACP,GACb,IAAMQ,EAAgBR,EAAMnF,WAAW4F,UAAU,EAC/CT,EAAMnF,WAAWW,OAAO,GAMtBL,EAASC,EAAaoF,GAM1B,OALIE,MAAMvF,KAERA,EAAS,IAGJ,CACLN,WAAY2F,EACZrF,OAAQA,MAGZ,MACF,IAAK,SAEHmF,KAAKC,UAAS,SAACP,GACb,IAAM7E,EAASC,EAAa4E,EAAMnF,YAClC,IAAI6F,MAAMvF,GAAV,CAKA,IAAIwF,EAAqB,CAAE9F,WAAYmF,EAAMnF,WAAYM,OAAQA,GAEjE,OADA6E,EAAMN,QAAQkB,KAAKD,GACZ,CACL9F,WAAYM,EACZA,OAAQ,GAGRuE,QAASM,EAAMN,QACfO,kBAAkB,OAGtB,MAEF,IAAK,WACL,IAAK,SACL,IAAK,WACL,IAAK,MACHK,KAAKC,UAAS,SAACP,GAKb,IAAIQ,EAAgB,EAAKL,mBAAmBH,EAAMnF,WAC9B0B,EAAe6D,IAG/BjF,EAASC,EAAaoF,GAI1B,OAHIE,MAAMvF,KACRA,EAAS,IAEJ,CACLN,WAAY2F,EACZrF,OAAQA,EACR8E,kBAAkB,MAGtB,MAEF,QACE,IAAMY,EAAgBhD,EAAMwC,OAAOS,YACnCR,KAAKC,UAAS,SAACP,GAGb,IAAIQ,EAAgB,EAAKL,mBAAmBH,EAAMnF,WAC9BgG,GAEhB1F,EAASC,EAAaoF,GAI1B,OAHIE,MAAMvF,KACRA,EAAS,IAEJ,CACLN,WAAY2F,EACZrF,OAAQA,EACR8E,kBAAkB,S,yCAMTpF,EAAYkG,GAiB7B,IAXoC,IAAhCT,KAAKN,MAAMC,mBAGW,IAApBS,MAAMK,KAKRlG,EAAa,IAGE,KAAfA,EAIF,MAAiB,MAAbkG,GAAiC,MAAbA,IAAwC,IAApBL,MAAMK,GAC5B,MAAbA,EAAmB,KAAOA,EAE1B,GAGoC,MAA3ClG,EAAWmG,OAAOnG,EAAWW,OAAO,IAAckF,MAAMK,KAIvClG,GAAN,MAAbkG,EAAiC,GAAmB,KAKtD,IAAME,EAAa,cAIfC,EAAgB,GAEpB,OAAID,EAAWE,KAAKtG,IAGlBqG,EAAgBrG,EAAWE,MAAMkG,GAAY,IACrB,IAApBP,MAAMK,IAE4B,IAAhCG,EAAcxF,QAAQ,KAIjBY,OAAO4E,IAAkBA,EAAcH,EAAWlG,EAAaA,GAAckG,EAI7ElG,EAAckG,EAGD,MAAbA,GAG8B,IAAhCG,EAAcxF,QAAQ,KAAcb,GAAckG,EACLlG,EAI7CA,EAAckG,GAMM,KAD7BG,EAAgBrG,EAAWE,MAnCP,QAmC4B,IAC9BS,QAKQ,IAApBkF,MAAMK,GAEDlG,EAAckG,EAGDlG,EAAW4F,UAAU,EAAG5F,EAAWW,OAAO,GACxCuF,EAQE,IAAtBlG,EAAWW,QAAgBkF,MAAMK,GAKf,MAAbA,EAAmBA,EAAW,IAEf,IAApBL,MAAMK,IAIc,MAAbA,IAGa,MAAlBG,GAA2C,MAAlBA,GAJtBrG,EAAckG,EAeDlG,EAAW4F,UAAU,EAAG5F,EAAWW,OAAO,GACtCuF,I,qCAO9BT,KAAKC,SAAS,CACZb,QAAS,O,0CAOX,IACE,IAAI0B,EAAgBC,KAAKC,MAAMC,aAAaC,QAAQ,kBAEpDJ,EAAgBd,KAAKC,SAAS,CAACb,QAAS0B,IACtCd,KAAKC,SAAS,CAACb,QAAS,KAC1B,MAAOzD,GACPwF,MAAMxF,M,2CAOR,IAAMyF,EAAcvD,SAASC,eAAe,gBACxCsD,EAAYC,aAAeD,EAAYE,YACdF,EAAYG,eACvCH,EAAYE,UAAYF,EAAYC,cAItCJ,aAAaO,QAAQ,gBAAiBT,KAAKU,UAAUzB,KAAKN,MAAMN,Y,+BAGhE,OACE,yBAAK1E,GAAG,kBACN,kBAAC,EAAD,CAASH,WAAYyF,KAAKN,MAAMnF,WAAYM,OAAQmF,KAAKN,MAAM7E,SAC/D,kBAAC,EAAD,CAASsD,YAAa6B,KAAK7B,cAC3B,kBAAC,EAAD,CAASiB,QAASY,KAAKN,MAAMN,QAASI,aAAcQ,KAAKR,eACzD,yBAAK9E,GAAG,QACN,uBAAGA,GAAG,MAAN,eAAuB,uBAAGgH,KAAK,6BAC7BC,MAAM,kBAAkB5B,OAAO,SAAS6B,IAAI,uBADvB,cAGvB,uBAAGlH,GAAG,gBAAe,oCAArB,6C,GApSQmH,IAAMC,YCHxBC,IAASC,OAAO,kBAAC,EAAD,MAASnE,SAASC,eAAe,W","file":"static/js/main.1f504d17.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Display = (props) => {\r\n  /* The role is to display the expression being typed and the \r\n   * result it gives after equal. The \"auxillary\" shows real-time \r\n   * result while the \"display\" shows the expression as it is being\r\n   * typed as well as the result when equals is clicked. When it shows\r\n   * the result of an equals though, the auxiliary doesn't show.\r\n   */\r\n  //const DMSA_REGEX_GROUP = /\\/|\\*|-|\\+/g;\r\n  \r\n  // Fontawesome icons are used in displaying *, / + sign so the regex \r\n  // gets these operators and replaces them with the fontawesome alternatives\r\n  const DMSA_REGEX_GROUP = /\\/|\\*|\\+/g;\r\n  \r\n  let modifiedExpression = props.expression;\r\n  modifiedExpression = modifiedExpression.replace(DMSA_REGEX_GROUP, (match) => {\r\n    switch(match) {\r\n      case '+':\r\n        return \"<i class='fas fa-plus'></i>\";\r\n      case '-':\r\n        return \"<i class='fas fa-minus'></i>\";\r\n      case '*':\r\n        return \"<i class='fas fa-times'></i>\";\r\n      case '/':\r\n        return \"<i class='fas fa-divide'></i>\";\r\n      default:\r\n        return match;\r\n    }\r\n  });\r\n  \r\n  return (\r\n    <div id=\"displayPanel\">\r\n      {/* When there is nothing provided as expression it renders as 0 --> \r\n      The dangerouslySetInnerHTML is to render the fontawesome icons as html*/}\r\n      { props.expression === \"\" ? <h1 id=\"display\">0</h1> :\r\n          <h1 id=\"display\" dangerouslySetInnerHTML=\r\n            {{__html: modifiedExpression}}></h1>\r\n      }\r\n      \r\n      {/* Real-time display of results. */}\r\n      { props.result === \"\" ? <h2 id=\"auxiliary\">&nbsp;</h2> : \r\n                              <h2 id=\"auxiliary\">{props.result}</h2> }\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Display;","/* Calc constants maps the id of the buttons to the values that \r\nwill be used in the program*/\r\nconst CALC_CONSTANTS = {\r\n  one: '1',\r\n  two: '2',\r\n  three: '3',\r\n  four: '4',\r\n  five: '5',\r\n  six: '6',\r\n  seven: '7',\r\n  eight: '8',\r\n  nine: '9',\r\n  zero: '0',\r\n  decimal: '.',\r\n  divide: '/',\r\n  multiply: '*',\r\n  subtract: '-',\r\n  add: '+',\r\n  clear: 'c',\r\n  backspace: 'backspace',\r\n  equals: '='\r\n}\r\nfunction handleEquals(expression) {\r\n  /* Evaluates the expression and returns the result. The expression is \r\n  split into groups by regex and using BODMSA-ish type of calculation, \r\n  evaluates the expression*/\r\n  const re = /\\d+[.0-9]*|(?<=\\B)-\\d+[.0-9]*|(?<=\\B)\\+\\d+[.0-9]*|\\D/g;\r\n  let stack = expression.match(re);         // The expression split into numbers\r\n                                            // and characters\r\n  const BODMAS = [\"/\", \"*\", \"-\", \"+\"];      // Each of the operators \r\n                                            // will be tested in this order\r\n  for (let i = 0; i < BODMAS.length; i++) {\r\n    let presentOperator = BODMAS[i];        // The present operator\r\n    \r\n    if (expression.indexOf(presentOperator) >= 0) {\r\n      // Is the operator even in the expression\r\n      for (let j = 1; j < stack.length; j += 2) { // valid expressions have the operators\r\n                                                  // At even positions\r\n        if (stack[j] === presentOperator) {\r\n          /* An operator is found. Get the value before it and after it,\r\n          calculate it applying the operator and replace it in the array.\r\n          */\r\n          let x = stack[j-1];\r\n          let y = stack[j+1];\r\n          const result = calculate(x, y, presentOperator);\r\n          let elementsBeforeX = stack.slice(0, j-1);\r\n          let elementsAfterY = stack.slice(j+2);\r\n          let newStack = [...elementsBeforeX, result, ...elementsAfterY];\r\n          stack = newStack;\r\n          j -= 2;               // So that we don't skip any operator \r\n                                // after a calculation\r\n        }\r\n      }\r\n    }\r\n  }\r\n  try {\r\n    return stack[0].toString();\r\n  } catch(err) {\r\n    return NaN;\r\n  }\r\n}\r\nfunction calculate(x, y, operator) {\r\n  x = Number(x);\r\n  y = Number(y);\r\n  switch(operator) {\r\n    case '/':\r\n      return x / y;\r\n    case '*':\r\n      return x * y;\r\n    case '+':\r\n      return x + y;\r\n    case '-':\r\n      return x - y;\r\n    default:\r\n      return -1;\r\n  }\r\n}\r\nexport { handleEquals };\r\nexport default CALC_CONSTANTS;","import React, { useEffect } from 'react';\r\nimport CALC_CONSTANTS from './calculator-constants';\r\n\r\nconst Buttons = (props) => {\r\n  /* This component handles everything about buttons. \r\n  As a button is clicked or a togglekey is pressed on the keyboard\r\n  It sends the event to the parent to take action accordingly. \r\n  Effects hook here to add and remove the key listener. */\r\n  useEffect(() => {\r\n    \r\n    function handleKeyPress(event) {\r\n      const keyPressed = event.key.toLowerCase();\r\n      switch(keyPressed) {\r\n        case '1': case '2': case '3': case '4': case '5': case '6': case '7':\r\n        case '8': case '9': case '0': case '.': case '/': case '*': case '-': \r\n        case '+': case 'backspace': case '=': \r\n          const keys = Object.keys(CALC_CONSTANTS);\r\n          let id = \"\";\r\n          for (let key in keys) {\r\n            // Each of the keyboard keys have an associated key in the object\r\n            // CALC_CONSTANTS which corresponds to the id of the button to \r\n            // be pressed.\r\n            if (CALC_CONSTANTS[keys[key]] === keyPressed) {\r\n              // We've found our id :)\r\n              id = keys[key];\r\n            }\r\n          }\r\n          document.getElementById(id).click();\r\n          break;\r\n        case 'enter': \r\n          document.getElementById(\"equals\").click();\r\n          break;\r\n        case 'c':\r\n          document.getElementById(\"clear\").click();\r\n          break;\r\n        case 'h':\r\n          document.getElementById(\"history-toggle\").click();\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n    }\r\n    document.addEventListener(\"keydown\", handleKeyPress);\r\n    \r\n    return () => {\r\n      document.removeEventListener(\"keydown\", handleKeyPress);\r\n    }\r\n  });\r\n  \r\n  return (\r\n    <div id=\"buttonPanel\">\r\n      {/* All the buttons in the app arranged here based on their arrangement\r\n          in the calculator. From left-to-right, up-to-down */}\r\n      <button id=\"clear\" onClick={props.handleClick}>C</button>\r\n      <button id=\"divide\" className=\"operator\" onClick={props.handleClick}>\r\n        <i className=\"fas fa-divide\"></i></button>\r\n      <button id=\"multiply\" className=\"operator\" onClick={props.handleClick}>\r\n        <i className=\"fas fa-times\"></i></button>\r\n      <button id=\"backspace\" className=\"operator\" onClick={props.handleClick}>\r\n        <i className=\"fas fa-backspace\"></i></button>\r\n      \r\n      <button id=\"seven\" onClick={props.handleClick}>7</button>\r\n      <button id=\"eight\" onClick={props.handleClick}>8</button>\r\n      <button id=\"nine\" onClick={props.handleClick}>9</button>\r\n      <button id=\"subtract\" className=\"operator\" onClick={props.handleClick}>\r\n        <i className=\"fas fa-minus\"></i></button>\r\n      \r\n      <button id=\"four\" onClick={props.handleClick}>4</button>\r\n      <button id=\"five\" onClick={props.handleClick}>5</button>\r\n      <button id=\"six\" onClick={props.handleClick}>6</button>\r\n      <button id=\"add\" className=\"operator\" onClick={props.handleClick}>\r\n        <i className=\"fas fa-plus\"></i></button>\r\n      \r\n      <button id=\"one\" onClick={props.handleClick}>1</button>\r\n      <button id=\"two\" onClick={props.handleClick}>2</button>\r\n      <button id=\"three\" onClick={props.handleClick}>3</button>\r\n      <button id=\"equals\" onClick={props.handleClick}><span style={{opacity:\"0\"}}>=</span><i className=\"fas fa-equals\"></i></button>\r\n      \r\n      <button id=\"zero\" onClick={props.handleClick}>0</button>\r\n      <button id=\"decimal\" onClick={props.handleClick}>.</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Buttons;","import React, { useState } from 'react';\r\n\r\nconst History = (props) => {\r\n  /* The component that shows all the calculations made in the \r\n  app. */\r\n  \r\n  // If the history panel with history is displaying or hidden.\r\n  const [ isDisplaying, toggleDisplay ] = useState(false);\r\n  \r\n  // Toggle the history panel from displaying to hide and vice-versa\r\n  function toggleHistory() {\r\n    return isDisplaying ? toggleDisplay(false) : toggleDisplay(true);\r\n  }\r\n  \r\n  \r\n  /* The widthType and heightType variables are used in relation\r\n  to responsive web design. On a smaller device the height of the \r\n  history is considered as the history will appear landscape and\r\n  underneath the calculator. On a larger one though, the height of the \r\n  history will be portrait and at the right side of the calculator so\r\n  it is the width that will be continuously changed  */\r\n  const widthType = {width: \"14vw\"};    // Bigger device. Width = 0\r\n  const heightType = {height: \"20vh\"};  // Smaller device. Height = 0\r\n  let calcHistoryProperty = {};         // The style it toggles depending \r\n                                        // on the screen size.\r\n  if (window.screen.width <= 480) {\r\n    calcHistoryProperty = heightType;\r\n  } else {\r\n    calcHistoryProperty = widthType;\r\n  }\r\n  \r\n  // The style on if the history is displaying or not\r\n  let calcHistoryStyle = {};\r\n  if (isDisplaying) {\r\n    // Here it simply sets its visibiity to visible.\r\n    calcHistoryStyle = calcHistoryProperty;\r\n    calcHistoryStyle.visibility = \"visible\";\r\n   } else {\r\n     // Here we don't know which property we have to set to 0 to \r\n     // hide the component as it could be width or height depending\r\n     // on the screen size.\r\n    let property = Object.keys(calcHistoryProperty)[0]; // The property\r\n    calcHistoryStyle = {\r\n      [property]: 0,\r\n      visibility: \"hidden\"\r\n    }\r\n  }\r\n  return (\r\n    <div id=\"historyPanel\">\r\n      {/* Show a different icon when the history is hidden or not */}\r\n      { isDisplaying ? <div id=\"history-toggle\" onClick={toggleHistory}>\r\n                          <i className=\"fas fa-chevron-left\"></i></div> : \r\n                       <div id=\"history-toggle\" onClick={toggleHistory}>\r\n                          <i className=\"fas fa-chevron-right\"></i></div>}\r\n      \r\n      {/* The calc-histoy may not or may not show (default) because of \r\n      the style given */}\r\n      <div id=\"calc-history\" style={calcHistoryStyle}>\r\n        <i className=\"fas fa-history\" id=\"history-icon\"></i>\r\n        \r\n        <div id=\"history\">\r\n          {/* It should not show any thing from history props if it is null */}\r\n          { props.history && props.history.map((item, index) => {\r\n            return <div key={index}><h3>{item.expression}</h3><p>{item.result}</p></div>\r\n          })}\r\n        </div>\r\n        \r\n          {/* A wrapper div that enables the clear button which is its child\r\n            to show the way did. Actually I don't understand how but it works so...*/}\r\n        { isDisplaying && <div id=\"wrapper\">\r\n              <div id=\"clear-history\" onClick={props.clearHistory}>\r\n              <i className=\"fas fa-trash-alt\"></i></div>\r\n            </div> }  \r\n      </div>\r\n      \r\n    </div>\r\n  );\r\n};\r\n\r\nexport default History;","import React from 'react';\nimport Display from './display';\nimport Buttons from './buttons';\nimport History from './history';\nimport './App.scss';\nimport CALC_CONSTANTS, { handleEquals } from './calculator-constants';\n\nclass App extends React.Component {\n  /**\n   *  Calculator app that persists data in the local storage\n   *  so that the user can continue seeing previous calculations made.\n   *  The state properties are majorly to pass to its child props to\n   *  display it except \"displayingEqusls\" which is used to monitor \n   *  whether the calculator is displaying a value after the equal to \n   *  button was clicked.\n   */\n  constructor(props) {\n    super(props);\n    this.state = {\n      expression: \"\",          // The expression to be evaluated.\n      result: \"\",              // The expression shown at the auxillary display\n                               // in order to see the calculator work as you\n                               // begin to type in the numbers\n      history: [],             // The previous calculations that has been done. \n                               // An array of objects of two properties corresponding\n                               // to an expression and its result. It's values\n                               // are stored in localStorage as JSON on each update.\n      displayingEquals: false  // If the equals button is clicked when a valid\n                               // expression has been typed. It is set to true\n    }\n    this.handleClick = this.handleClick.bind(this);\n    this.clearHistory = this.clearHistory.bind(this);\n    this.validateExpression = this.validateExpression.bind(this);\n  }\n  handleClick(event){\n    // On the event that the user either clicked a button or \n    // press the corresponding key on the keyboard.\n    const charClicked = event.target.id;      // The button the user clicked\n    switch(charClicked) {\n      case \"clear\":                           // Effectively clears the display\n        this.setState({\n          expression: \"\",\n          result: \"\"\n        });\n        break;\n      case \"backspace\":                 // Remove the last typed digit/operator\n        this.setState((state) => {\n          const newExpression = state.expression.substring(0, \n            state.expression.length-1);\n          \n          // The handleEquals allow calculations to be done as the user\n          // is either inputing or deleting values but sometimes the \n          // expression is not valid one so then it is set to an empty string\n          // in this case.\n          let result = handleEquals(newExpression);\n          if (isNaN(result)) {\n            // An invalid expression\n            result = \"\";\n          }\n          \n          return {\n            expression: newExpression,\n            result: result\n          }\n        });\n        break;\n      case \"equals\":                // The equals button has been clicked\n                                    // Leave if the expression was not valid\n        this.setState((state) => {\n          const result = handleEquals(state.expression);\n          if (isNaN(result)) {\n            return;\n          }\n          // Save to history. It's only when the equals button has been clicked\n          // that the expression can be saved to history (if valid)\n          let completeExpression = { expression: state.expression, result: result }\n          state.history.push(completeExpression);\n          return {\n            expression: result,\n            result: \"\",             // When displaying the result of an expression,\n                                    // The other auxiliary that updates as\n                                    // the user types should not display also\n            history: state.history,\n            displayingEquals: true  // It just performed an equals to operation\n          }\n        });\n        break;\n      /* Bunch of cases that handle operators /, * ,- ,+ */\n      case \"multiply\":\n      case \"divide\":\n      case \"subtract\":\n      case \"add\":\n        this.setState((state) => {\n          // The user can type in a number of operators and digits\n          // in different formats in any manner even if it may render\n          // the expression invalid. So the method checks to make sure \n          // that the user types in the next right thing. \n          let newExpression = this.validateExpression(state.expression, \n                              CALC_CONSTANTS[charClicked]);\n          \n          // Updating result display as the user types as previously explained\n          let result = handleEquals(newExpression);\n          if (isNaN(result)) {\n            result = \"\";\n          }\n          return {\n            expression: newExpression,    // Just the expression yet to be calculated\n            result: result,               // Shows in case the expression is valid\n            displayingEquals: false       // It did not just perform an equals to \n          }\n        });\n        break;\n      /* Cases that handle digits 0-9*/\n      default:\n        const letterClicked = event.target.textContent;\n        this.setState((state) => {\n          // It'll still need to be validated (Needs less validation than \n          // operators though)\n          let newExpression = this.validateExpression(state.expression, \n                              letterClicked);\n          // Real-time updating (as usual)\n          let result = handleEquals(newExpression);\n          if (isNaN(result)) {\n            result = \"\";\n          }\n          return {    // same as for operators\n            expression: newExpression,\n            result: result,\n            displayingEquals: false\n          }\n        });\n    }\n  }\n  \n  validateExpression(expression, nextChar) {\n    /* Well this is the function that validates an expression to see\n    if it will allow the user to click the next number/operator. It takes\n    the expression as parameter and nextChar as the next character (number \n    or operator) that wants to be added to the expression. \n    This method is a bit verbose but it works so let's just call it a day.*/\n    if (this.state.displayingEquals === true) {\n      // When an equals to operation has been done, clicking a new number\n      // starts another expression.\n      if (isNaN(nextChar) === false) {\n        // But then the next character clicked must be a number. \n        // If an operator is supplied instead, then the operator appends\n        // the expression and another expression is continued from the \n        // result of the previous.\n        expression = \"\";\n      }\n    }\n    if (expression === \"\") {\n      // The default state. Nothing is actually in the expression\n      // First char can start with \"-\" or a number or a decimal point in which\n      // Zero will be appended before the decimal point.\n      if (nextChar === '-' || nextChar === '.' || isNaN(nextChar) === false) {\n        return nextChar === '.' ? \"0.\" : nextChar;\n      } else {\n        return \"\";\n      }\n    }\n    if (expression.charAt(expression.length-1) === '.' && isNaN(nextChar)) {\n      // If there was a decimal point and the next character is an operator,\n      // then zero should be appended to the expression before the next character\n      // can be appended. This is to prevent multiple decimal points per number.\n      nextChar === '.' ? expression += \"\" : expression += \"0\";\n    }\n    \n    /* The Regex that is used to get the last group of numbers \n       or last operators in an expression */\n    const digitRegex = /\\d+[.0-9]*$/;\n    const operatorRegex = /\\W+$/;\n    \n    // The last group of numbers or operators the regex will match\n    let lastCharGroup = \"\";\n    \n    if (digitRegex.test(expression)) {\n      // The last group of characters are numbers with or without\n      // a decimal point. e.g. 123, 1.23, 12.3, 123.0\n      lastCharGroup = expression.match(digitRegex)[0];\n      if (isNaN(nextChar) === false) {\n        // The next character typed is a number just append it to the expression\n        if (lastCharGroup.indexOf('.') === -1) {\n          // If there is no decimal point in the expression, check if the number\n          // starts with multiple zeros. If I add the next number to the previous\n          // will the value of the previous change?\n          return Number(lastCharGroup) == lastCharGroup+nextChar ? expression : expression += nextChar;          \n        } else {\n          // We can't test here because we cannot predict the extent of zeros a \n          // use can type when the number has a decimal point.\n          return expression += nextChar;\n          \n        }\n      } else if (nextChar === '.') {\n        // A decimal point wants to be typed. There should be only one\n        // decimal point in the number.\n        return lastCharGroup.indexOf('.') === -1 ? expression += nextChar: \n                                                            expression;\n      } else {\n        // It is an operator - either /, *, -, +. It's okay. Just append it\n        // like we did with the number\n        return expression += nextChar;\n      }\n    } else {\n      // The last group of characters are operators - may be more \n      // than one (e.g. *-, /-) or just one /, *, -, +.\n      lastCharGroup = expression.match(operatorRegex)[0];\n      if (lastCharGroup.length === 2) {\n        // There are more than one operators present already\n        // Maybe *- or /-. So if the next character is a number it gladly\n        // appends it normally but if not then the operator replaces the\n        // two operators present.\n        if (isNaN(nextChar) === false) {\n          // The next character is a number\n          return expression += nextChar;\n        } else {\n          // The next character is an operator. Replace the TWO last characters\n          let newExpression = expression.substring(0, expression.length-2) \n                              + nextChar;\n          return newExpression;\n        }\n      } else {\n        // There is just one operator present. If the next character is a\n        // number, it's alright. Else if it's an operator, the operator should\n        // either replace the present one or add to the present one based on \n        // if the present one is * or / and operator is - (so we can do *-, /-)\n        if (expression.length === 1 && isNaN(nextChar)) {\n          // There is only one operator present and it is the only \n          // expression (So it's probably -). Only a minus is allowed.\n          // It does nothing effectively though as it just replaces\n          // the old one.\n          return nextChar === '-' ? nextChar : \"\";\n        }\n        if (isNaN(nextChar) === false) {\n          // Just a number. Append it to the expression. (Numbers don't have\n          // much problem as we can see)\n          return expression += nextChar;\n        } else if (nextChar === '-') {\n          // If the new character is a - it can only add to the previous operators\n          // if they are * or /\n          if (lastCharGroup === '/' || lastCharGroup === '*') {\n            return expression += nextChar;\n          } else {\n            // The new character is not a - .Just replace the previuos operator.\n            let newExpression = expression.substring(0, expression.length-1)\n                                + nextChar;\n            return newExpression;\n          }\n        } else {\n          // Every other condition failed. It's just an operator to be added\n          // to an expression. No big deal about the - or * or / state.\n          let newExpression = expression.substring(0, expression.length-1)\n                                + nextChar;\n            return newExpression;\n        }\n      }\n    }\n  }\n  clearHistory(){\n    this.setState({\n      history: []\n    });\n  }\n  \n  componentDidMount() {\n    /* Try to get the saved history if the user has previously used the\n    calculator. It was saved in JSON format. */\n    try {\n      let storedHistory = JSON.parse(localStorage.getItem(\"jsCalcHistory\"));\n      // Returns null if there is no history saved.\n      storedHistory ? this.setState({history: storedHistory}) : \n        this.setState({history: []});\n    } catch (err) {\n      alert(err);\n    }\n  }\n  \n  componentDidUpdate() {\n    /* To make sure that the history pane is always scrolled to the bottom. \n    I may as well have done it in its own History component. My bad.*/\n    const calcHistory = document.getElementById(\"calc-history\");\n    if (calcHistory.scrollHeight - calcHistory.scrollTop !== \n                                 calcHistory.clientHeight) {\n      calcHistory.scrollTop = calcHistory.scrollHeight;\n    }\n    \n    // Save the history to the local storage.\n    localStorage.setItem(\"jsCalcHistory\", JSON.stringify(this.state.history));\n  }\n  render() {\n    return (\n      <div id=\"calculator-app\">\n        <Display expression={this.state.expression} result={this.state.result} />\n        <Buttons handleClick={this.handleClick} />\n        <History history={this.state.history} clearHistory={this.clearHistory} />\n        <div id=\"info\">\n          <p id=\"me\">Designed by <a href=\"https://codepen.io/HealerC\" \n            title=\"codepen@HealerC\" target=\"_blank\" rel=\"noopener noreferrer\">Uyioghosa</a>\n          </p>\n          <p id=\"instructions\"><b>Keys:</b> [0-9/*-+=], C, H, backspace, enter</p>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}